#ifndef PMD2_HPP
#define PMD2_HPP
/*
pmd2.hpp
2015/09/11
psycommando@gmail.com
Description:
    Contains declarations and tools that applies to the entirety of the PMD2 games.
*/
#include <cstdint>
#include <array>
#include <string>
#include <sstream>
#include <iosfwd>
/*
    A macro for eventually exporting symbols through a DLL.
*/
#ifdef _WIN32
    #if defined(PPMDU_DLL_IMPORT)
        #define PPMDU_API __declspec(dllimport)
    #elif defined(PPMDU_DLL_EXPORT)
        #define PPMDU_API __declspec(dllexport)
    #else
        #define PPMDU_API
    #endif // DEBUG
#else//if //defined(__linux__)
    #define PPMDU_API
#endif

//Stream operator for toolkit version
namespace pmd2 { struct toolkitversion_t; };
std::ostream& operator<< (std::ostream& stream, const pmd2::toolkitversion_t & tkitver);

namespace pmd2
{
    class exBasePPMDUException                : public std::runtime_error  { public: using std::runtime_error::runtime_error;  };           //! #REMOVE
    class exMalformedEscapedCharacterSequence : public exBasePPMDUException{ public: using exBasePPMDUException::exBasePPMDUException; };   //! #REMOVE

//======================================================================================
//  Constants
//======================================================================================
    /*
        Common XML strings used to name some attributes and nodes throughout the project!
    */
    const std::string CommonXMLGameVersionAttrStr = "gameVersion";
    const std::string CommonXMLGameRegionAttrStr  = "gameRegion";
    const std::string CommonXMLToolVersionAttrStr = "libVersion";

    /*
        Toolset version struct
            Meant to store the ppmdu lib's internal version, which differs from each utility's version.
    */
    struct toolkitversion_t
    { 
        unsigned int major, minor, patch; 

        toolkitversion_t(unsigned int maj=0, unsigned int min=0, unsigned int ptch=0)
            :major(maj), minor(min),patch(ptch)
        {}

        inline bool operator==( const toolkitversion_t& other )const { return major == other.major && minor == other.minor && patch == other.patch; }
        inline bool operator!=( const toolkitversion_t& other )const { return !operator==(other); }

        operator std::string()const
        {
            std::stringstream converted;
            converted << *this;
            return converted.str();
        }

    };
    toolkitversion_t ParseToolsetVerion( const std::string & verstxt );

    /*
        Current version string. Represents the version of the PPMDU library used.
    */
    const toolkitversion_t PMD2ToolsetVersionStruct{0,2,0};

    /*******************************************************************************
        eGameVersion
            Unique IDs for each versions of the PMD2 games.
    *******************************************************************************/
    enum struct eGameVersion : size_t 
    {
        EoS = 0,        //Explorers of Sky
        EoT,        //Explorers of Time
        EoD,        //Explorers of Darkness
        //EoTEoD,     //Both/either Explorers of Time/Darkness

        NBGameVers, //Must be before last
        Invalid,
    };

    /*******************************************************************************
        eGameRegion
            Locale of the game. Used mainly for determining offsets differences 
            between versions.
    *******************************************************************************/
    enum struct eGameRegion : size_t 
    {
        Japan = 0,
        NorthAmerica,
        Europe,

        NBRegions, //Must be before last
        Invalid,
    };

    /*******************************************************************************
        eGameLanguages
            List of the different possible languages.
            Each language's value is the letter suffix for its text_*.str file name.
    *******************************************************************************/
    enum struct eGameLanguages : size_t 
    {
        english = 0,
        japanese,
        french ,
        german ,
        italian,
        spanish,

        NbLang, //Must before last
        Invalid,
    };


    /*******************************************************************************
        eHCDataLoadSrc
            Used to specify a source from where to dump certain hard coded data from the pmd2 games
    *******************************************************************************/
    enum struct eHCDataLoadSrc
    {
        ParseFromBin,           //Read straight from the game's binaries.
        ParseFromModdedFile,    //Read from modded files generated by the tool prior.
        ParseFromXML,           //Read data from an xml file loaded at runtime.

        NbSrcs, //Must before last
        Invalid,
    };

    //Common error string
    const std::string Generic_Invalid   = "INVALID";

    /*******************************************************************************
        Event/Resource Names
    *******************************************************************************/
    const std::string ResourcePrefix_A = "a";   //Acting?
    const std::string ResourcePrefix_B = "b";
    const std::string ResourcePrefix_C = "c";
    const std::string ResourcePrefix_D = "d";   //Dungeon
    const std::string ResourcePrefix_G = "g";   //Guild
    const std::string ResourcePrefix_H = "h";   //Home?
    const std::string ResourcePrefix_M = "m";   //Main
    const std::string ResourcePrefix_N = "n";   
    const std::string ResourcePrefix_P = "p";   //Part?/Path?
    const std::string ResourcePrefix_S = "s";
    const std::string ResourcePrefix_T = "t";   //Town
    const std::string ResourcePrefix_V = "v";   //Visual?

    /*******************************************************************************
        List of directory names from the PMD2 games.
    *******************************************************************************/
    const std::string DirName_DefData     = "data";
    const std::string DirName_DefOverlay  = "overlay";

    const std::string DirName_BACK        = "BACK";
    const std::string DirName_BALANCE     = "BALANCE";
    const std::string DirName_DUNGEON     = "DUNGEON";
    const std::string DirName_EFFECT      = "EFFECT";
    const std::string DirName_FONT        = "FONT";
    const std::string DirName_GROUND      = "GROUND";
    const std::string DirName_MAP_BG      = "MAP_BG";
    const std::string DirName_MESSAGE     = "MESSAGE";
    const std::string DirName_MONSTER     = "MONSTER";
    const std::string DirName_RESCUE      = "RESCUE";   //EoS Only
    const std::string DirName_SCRIPT      = "SCRIPT";
    const std::string DirName_SOUND       = "SOUND";
    const std::string DirName_SYNTH       = "SYNTH";    //EoS Only
    const std::string DirName_SYSTEM      = "SYSTEM";
    const std::string DirName_TABLEDAT    = "TABLEDAT"; //EoS Only
    const std::string DirName_TOP         = "TOP";

    /*******************************************************************************
        List of some unique filenames from PMD2 games.
    *******************************************************************************/
    const std::string FName_MonsterMND   = "monster.mnd";

    /*******************************************************************************
        Language file names
            text_e.str for example

        !#FIXME: Its probably  not a good idea to have those static in here, 
                 when we can query the text_*.str filename from the xml file
                 instead.
    *******************************************************************************/
    //!#FIXME: Should use GameLangLoader instead!
    const std::string FName_TextPref      = "text"; 
    const std::string FName_TextEngSufx   = "e";
    const std::string FName_TextJapSufx   = "j";
    const std::string FName_TextFreSufx   = "f";
    const std::string FName_TextGerSufx   = "g";
    const std::string FName_TextItaSufx   = "i";
    const std::string FName_TextSpaSufx   = "s";

    /*******************************************************************************
        GameLanguagesNames
            
    *******************************************************************************/
    extern const std::array<std::string, static_cast<size_t>(eGameLanguages::NbLang)> GameLanguagesNames;

    inline eGameLanguages StrToGameLang( const std::string & lang )
    {
        for( size_t cntlang = 0; cntlang < GameLanguagesNames.size(); ++cntlang )
            if( lang == GameLanguagesNames[cntlang] ) return static_cast<eGameLanguages>(cntlang);
        return eGameLanguages::Invalid;
    }

    inline const std::string & GetGameLangName( eGameLanguages lang )
    {
        if( lang < eGameLanguages::NbLang )
            return GameLanguagesNames[static_cast<size_t>(lang)];
        else
            return Generic_Invalid;
    } 

    /*******************************************************************************
        GameVersionNames
            For a given eGameVersion ID returns a string that represents the game version.
    *******************************************************************************/
    extern const std::array<std::string, static_cast<size_t>(eGameVersion::NBGameVers)> GameVersionNames;

    inline const std::string & GetGameVersionName( eGameVersion gv )
    {
        if( gv < eGameVersion::NBGameVers )
            return GameVersionNames[static_cast<size_t>(gv)];
        else
            return Generic_Invalid;
    }

    inline eGameVersion StrToGameVersion( const std::string & strvers )
    {
        for( size_t i = 0; i < GameVersionNames.size(); ++i )
        {
            if( strvers == GameVersionNames[i] )
                return static_cast<eGameVersion>(i);
        }
        return eGameVersion::Invalid;
    }

    /*******************************************************************************
        GameRegionNames
            
    *******************************************************************************/
    extern const std::array<std::string,static_cast<size_t>(eGameRegion::NBRegions)> GameRegionNames;

    inline const std::string & GetGameRegionNames( eGameRegion gr )
    {
        if( gr < eGameRegion::NBRegions )
            return GameRegionNames[static_cast<size_t>(gr)];
        else
            return Generic_Invalid;
    }

    inline eGameRegion StrToGameRegion( const std::string & strregion )
    {
        for( size_t i = 0; i < GameRegionNames.size(); ++i )
        {
            if( strregion == GameRegionNames[i] )
                return static_cast<eGameRegion>(i);
        }
        return eGameRegion::Invalid;
    }


//
//  Strings
//
    //escapejis : whether Shift-JIS character sequences should be escaped or not. Should be false for strings from the Japanese version of the game
    std::string EscapeUnprintableCharacters( const std::string & src, bool escapejis, bool escapeforxml, const std::locale & loc );
    std::string ReplaceEscapedCharacters   ( const std::string & src, const std::locale & loc );
    std::string & ReplaceEscapedSequenceTest( std::string & str );

//======================================================================================
//  PMD2 Version and Region Detection Utilities
//======================================================================================
    /*
        DetermineGameVersionAndLocale
            Returns both the locale and the version of PMD2 that the target ROM filesystem is from.
    */
    std::pair<eGameVersion,eGameRegion> DetermineGameVersionAndLocale( const std::string & pathfilesysroot );

    /*
        AnalyzeDirForPMD2Dirs
            Determine the version of PMD2 from looking at the ROM filesystem directories structure.
    */
    eGameVersion                        AnalyzeDirForPMD2Dirs      ( const std::string & pathdir );



};

#endif